#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <unordered_map>
#include <set>
#include <algorithm>
#include <stack>


class Vertex {
public:
  int in_edge{0};

  int out_edge{0};

  std::string name;
};

class Graph {
public:
  Graph(const std::filesystem::path& path) {
    _graph_path = path / path.filename();
    _graph_path += ".graph_new";
    
    _edge_path = path / path.filename();
    _edge_path += ".edges";
    
    _vertex_path = path / path.filename();
    _vertex_path += ".vertices";

    _statistics_path = path / path.filename();
    _statistics_path += ".statistics";
     
    _build_adjacency_list();

    find_linear_chain();
    
    //_generate_edge_file();

    //_generate_vertex_file();

    _generate_statistics_file();

  }

  int get_number_edges() const {
    return _num_edges;
  }

  int get_number_vertices() const {
    return _num_vertices;
  }

  int get_number_linear_chain() const {
    return _num_linear_chain;
  }

  void find_linear_chain();

private:
  int _num_edges {0};
  
  int _num_vertices {0};

  int _num_linear_chain{0};

  std::filesystem::path _graph_path;
  
  std::filesystem::path _edge_path;
  
  std::filesystem::path _vertex_path;
  
  std::filesystem::path _statistics_path;

  std::set<Vertex> _vertices;
  
  std::unordered_map<std::string, int> _name2id;
    
  std::unordered_map<std::string, std::set<std::string>> _adjacency_list;
  
  std::vector<std::vector<std::string>> _linear_chain;

  void _build_adjacency_list();
    
  void _generate_edge_file();

  void _generate_vertex_file();
  
  void _generate_statistics_file();

  void _find_zero_in_edge(std::vector<std::string>&) const;

  int _calculate_in_edge(std::string&) const;
};

void Graph::_build_adjacency_list() {

  std::ifstream gfile;
  gfile.open(static_cast<std::string>(_graph_path));

  std::string line;
  std::string delimiter = "\" -> \"";
 
  if (gfile.is_open()) {
    while (std::getline(gfile, line)) {
      size_t spos = 0;
      size_t epos = line.find(delimiter);
      std::string token;
      std::string key;
      
      while (epos != std::string::npos) {
        //std::cout << line << '\n'; 
        token = line.substr(spos, epos);
        //std::cout << "token = " << token << std::endl;
        
        key = token.substr(3, token.length());
        if (_adjacency_list.find(key) == _adjacency_list.end()) {
          _adjacency_list[key] = std::set<std::string>{};
        }

        spos = epos + delimiter.length();
        epos = line.find(delimiter, spos);
        token = line.substr(spos, epos);
        _adjacency_list[key].insert(token.substr(0, token.length()-2));

        _vertices.insert(key);
        _vertices.insert(token.substr(0, token.length()-2));

        break;
      }
    }
  }
  else {
    std::cout << "can not open " << _graph_path << '\n';
  }

  gfile.close();

  for (auto& [key, values] : _adjacency_list) {
    for (auto& v : values) {
      ++_num_edges;
    }
  }
  
  _num_vertices = _vertices.size();
}

void Graph::_generate_edge_file() {
  std::ofstream file;
  file.open(static_cast<std::string>(_edge_path));

  for (auto& [key, values] : _adjacency_list) {
    for (auto& v : values) {
      file << key << "->" << v << '\n';
    }
  }

  file.close();
}

void Graph::_generate_vertex_file() {
  std::ofstream file;
  file.open(static_cast<std::string>(_vertex_path));

  for (auto& v : _vertices) {
    file << v << '\n';
  }

  file.close();
}

void Graph::_generate_statistics_file() {
  std::ofstream file;
  file.open(static_cast<std::string>(_statistics_path));
  file << std::setw(8) << "|V|"
       << std::setw(8) << "|E|"
       << std::setw(8) << "|P|"
       << std::setw(10) << "%" << '\n';

  file << std::setw(8) << _num_vertices
       << std::setw(8) << _num_edges
       << std::setw(8) << _num_linear_chain
       << std::setw(10) << 100.0*_num_linear_chain/_num_vertices
       << '\n';

  file.close();
}


void Graph::_find_zero_in_edge(std::vector<std::string>& v) const {
  bool hit = false;

  for (auto& vertex : _vertices) {
    std::cout << vertex << '\n';
    hit = false;
    for (auto& [key, values] : _adjacency_list) {
      if (std::find(values.begin(), values.end(), vertex) != values.end()) {
        hit = true;
        break;
      }
    }
    if (!hit) {
      v.push_back(vertex);
    }
  }
}

int Graph::_calculate_in_edge(std::string& str) const {
  int in_edge = 0;

  for (auto& [key, values] : _adjacency_list) {
    if (std::find(values.begin(), values.end(), str) != values.end()) {
      ++in_edge;
    }
  }
  return in_edge;
}

//void dump_stack(std::stack<std::string> stk) {
//  std::cout << "elements in stack : ";
//  while (!stk.empty()) {
//    std::cout << stk.top() << ' ';
//    stk.pop();
//  }
//  std::cout << '\n';
//}

void Graph::find_linear_chain() {
  std::cout << "in find linear chain\n";
  // vertices of zero in edge
  std::vector<std::string> v_zero_in;
  _find_zero_in_edge(v_zero_in);

  std::stack<std::string> stk; 
  std::vector<std::string> visited;

  for (auto& v : v_zero_in) {
    stk.push(v);
    visited.push_back(v);
  }
  
  std::vector<std::string> lchain;
    
  while (!stk.empty()) {
    //dump_stack(stk);

    std::string s = stk.top();
    stk.pop();
    std::cout << s << '\n';
    if (_calculate_in_edge(s) > 1) {
      if (lchain.size() > 1) { 
        _linear_chain.push_back(lchain);
      }
      lchain.clear();
    }
    
    lchain.push_back(s);

    // s has no child
    if (_adjacency_list.find(s) == _adjacency_list.end()) {
      if (lchain.size() > 1) { 
        _linear_chain.push_back(lchain);
      }
      lchain.clear();
    }

    std::string child;
    // s has children
    while (_adjacency_list.find(s) != _adjacency_list.end()) {
      // has only one child
      if ((_adjacency_list[s]).size() == 1) {
        child = *(_adjacency_list[s].begin());
        // the child has more than one in_edge
        if (_calculate_in_edge(child) > 1) {
          if (lchain.size() > 1) {
            _linear_chain.push_back(lchain);
          }
          lchain.clear();
          
          if (std::find(visited.begin(), visited.end(), child) == visited.end()) {
            stk.push(child);
            visited.push_back(child);
          }
          break;
        }
        // the child has only one in_edge
        else {
          lchain.push_back(child);
          s = child;
        }
      }
      // has more than one children
      else {
        for (auto& c : _adjacency_list[s]) {
          if (std::find(visited.begin(), visited.end(), c) == visited.end()) {
            stk.push(c);
            visited.push_back(c);
          }
        }

        if (lchain.size() > 1) {
          _linear_chain.push_back(lchain);
        }
        lchain.clear();
        break;
      }
    }

  }
   
  //std::cout << "linear chain :::\n"; 
  for (auto& chain : _linear_chain) {
    for (auto& c : chain) {
      ++_num_linear_chain;
  //    std::cout << c << ' ';
    }
  //  std::cout << '\n';
  }
}
